struct List<T> {
    (V) '--' (V)
}

intr List<T> {
   Printable,
   Addable,
}

impl List<T> {
    ///
    /// Add two lists together by appending element to self
    /// This really should return a new list with the modifications
    /// But instead, it just modifies in place for now
    ///
    fn operatorAdd(T element) -> List<T> {
        (V) '--' (V)
    }

    ///
    /// Returns the element of the list at a given index
    /// This should do bounds checking, but instead it just segfaults right now
    ///
    fn get(Int index) -> T {
        (V) '--' (V)
    }

    ///
    /// Returns the length of this list
    /// In other words, returns the number of elements that are currently contained in this list
    ///
    fn len() -> Int {
        (V) '--' (V)
    }

    ///
    /// Add two lists together by appending element to self
    /// This really should return a new list with the modifications
    /// But instead, it just modifies in place for now
    ///
    fn append(T other) -> List<T> {
        return self + other
    }

    ///
    /// Add two lists together by appending element to self
    /// This really should return a new list with the modifications
    /// But instead, it just modifies in place for now
    ///
    fn push(T other) -> List<T> {
        return self + other
    }

    ///
    /// Add two lists together by appending element to self
    /// This really should return a new list with the modifications
    /// But instead, it just modifies in place for now
    ///
    fn add(T other) -> List<T> {
        return self + other
    }

    fn toString() {
        let i = 0
        let result = "["
        while i < self.len() {
            // TODO: If T is already a string, use quotes to denote that
            result = result + " " + self.get(i).toString() + ","
        }
        return result + "]"
    }
}

fn __new_list__<T>(Int capacity=128) -> List<T> {
    (V) '--' (V)
}
