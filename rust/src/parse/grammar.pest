WHITESPACE = _{ " " | NEWLINE }
COMMENT = _{ ("#" | "//") ~ (!NEWLINE ~ ANY)* ~ NEWLINE }

reserved_word = { "true" | "false" | "if" | "else" | "while" | "do" | "struct" | "impl" | "fn" }
ident = @{ !(reserved_word) ~ ((ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*) }

program = { SOI ~ (function | crab_struct | impl_block)+ ~ EOI }

crab_struct = { "struct" ~ ident ~ "{" ~ struct_fields? ~ "}" }
struct_fields = _{ struct_field ~ ("," ~ struct_field)* ~ ","?}
struct_field = { crab_type ~ ident }
struct_init = { ident ~ "{" ~ struct_fields_init? ~ "}" }
struct_fields_init = _{ struct_field_init ~ ("," ~ struct_field_init)* ~ ","? }
struct_field_init = { ident ~ "=" ~ expression }

impl_block = { "impl" ~ ident ~ ("of " ~ ident)? ~ "{" ~ (function*) ~ "}" }

function = { fn_signature ~ code_block }
fn_signature = { "fn" ~ ident ~ "(" ~ fn_params? ~ ","?  ~ ")" ~ ("->" ~ crab_type)? }
fn_call = { ident ~ "(" ~ fn_args? ~ ","? ~ ")" }
named_expression = { ident ~ "=" ~ expression }
fn_args = _{ (named_expression | expression) ~ ("," ~ (named_expression | expression))* }
named_fn_param = { crab_type ~ ident ~ "=" ~ expression }
fn_param = { crab_type ~ ident }
fn_params = _{ (named_fn_param | fn_param) ~ ("," ~ (named_fn_param | fn_param))* }

code_block = { "{" ~ statement* ~ "}" }
expression = { primitive | struct_init | expression_chain }
expression_chain = { (fn_call | ident) ~ ("." ~ (fn_call | ident))* }

// TODO: Using an expression chain here is too permissive -- Simply accessing a struct's field as a statement makes no sense
statement = { (return_stmt | assignment | reassignment | expression_chain | if_stmt | while_stmt | do_while_stmt ) }
assignment = { "let" ~ ident ~ "=" ~ expression }
reassignment = { ident ~ "=" ~ expression }
return_stmt = { "return" ~ expression? }

if_stmt = { "if" ~ expression ~ code_block ~ else_stmt? }
else_stmt = { "else" ~ (if_stmt | code_block) }

while_stmt = { "while" ~ expression ~ code_block }
do_while_stmt = { "do" ~ code_block ~ "while" ~ expression }
// TODO: After iterators
// for_stmt = { "for" ~ ident ~ "in" ~ expression ~ code_block }

primitive = { (uint64_primitive | string_primitive | bool_primitive) }
uint64_primitive = @{ ASCII_DIGIT+ }
bool_primitive = { "true" | "false" }

string_primitive = ${ ("\"" | NEWLINE) ~ string_inner ~ "\"" }
string_inner = @{ char* }
char = @{ !("\"" | "\\") ~ ANY | ("\\" ~ ( "n" )) }

// For now, we're only allowing primitive types
crab_type = @{ ( "Int" | "String" | "Float" | "Bool" ) }
